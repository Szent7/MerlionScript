package src

import (
	"MerlionScript/services/common"
	skladTypes "MerlionScript/services/sklad/types"
	"MerlionScript/utils/db/interfaceDB"
	"context"
	"fmt"
	"log"
	"time"
)

// Обновляем остатки в ERP
func UpdateRemainsERP(ctx context.Context, dbInstance interfaceDB.DB, service common.Service, erpSystem common.ERPSystem) error {
	var ServiceName string = service.GetSystemName()
	var DBTableName string = service.GetDBTableName()
	select {
	case <-ctx.Done():
		fmt.Printf("%s (UpdateRemainsERP): работу закончил из-за контекста\n", ServiceName)
		return nil
	default:
		fmt.Printf("%s: начал обновлять остатки\n", ServiceName)
		//Мета организации ERP
		orgMeta, err := erpSystem.GetOrgMeta(service.GetOrgName())
		if err != nil || orgMeta.Href == "" {
			log.Printf("%s (UpdateRemainsERP): ошибка при получении метаданных организации | err = %s\n", ServiceName, err)
			return err
		}
		//Мета склада ERP
		storeMeta, err := erpSystem.GetStoreMeta(service.GetStoreName())
		if err != nil || storeMeta.Href == "" {
			log.Printf("%s (UpdateRemainsERP): ошибка при получении метаданных склада | err = %s\n", ServiceName, err)
			return err
		}
		//ID склада ERP
		storeUUID, err := erpSystem.GetStoreUUID(service.GetStoreName())
		if err != nil || storeUUID == "" {
			log.Printf("%s (UpdateRemainsERP): ошибка при получении UUID склада | err = %s\n", ServiceName, err)
			return err
		}
		//Записи из БД
		items, err := dbInstance.GetCodesFilledMS(DBTableName)
		if err != nil || items == nil {
			log.Printf("%s (UpdateRemainsERP): ошибка при получении записей из БД | err = %s\n", ServiceName, err)
			return err
		}
		//Остатки с сервиса
		itemsService, err := service.GetStocksList(ctx, dbInstance)
		if err != nil || itemsService == nil {
			log.Printf("%s (UpdateRemainsERP): ошибка при получении записей из сервиса | err = %s\n", ServiceName, err)
			return err
		}
		//На увеличение остатков
		acceptanceReq := skladTypes.Acceptance{
			Organization: skladTypes.MetaMiddle{Meta: orgMeta},
			Agent:        skladTypes.MetaMiddle{Meta: orgMeta},
			Store:        skladTypes.MetaMiddle{Meta: storeMeta},
			Description:  "Automatically generated by the script",
			Applicable:   true,
		}
		//На снижение остатков
		woffReq := skladTypes.Acceptance{
			Organization: skladTypes.MetaMiddle{Meta: orgMeta},
			Agent:        skladTypes.MetaMiddle{Meta: orgMeta},
			Store:        skladTypes.MetaMiddle{Meta: storeMeta},
			Description:  "Automatically generated by the script",
			Applicable:   true,
		}
		//Список приемки
		acceptanceList := []skladTypes.PositionsAdd{}
		//Список списания
		woffList := []skladTypes.PositionsAdd{}
		for _, item := range *items {
			select {
			case <-ctx.Done():
				return nil
			default:
				//Запись ERP
				itemERP, err := erpSystem.GetItemAvails(item.Codes.MoySkladCode, storeUUID)
				if err != nil || itemERP.ItemMeta.Href == "" {
					log.Printf("%s (UpdateRemainsERP): ошибка при получении записей из ERP | erpCode = %s; err = %s\n", ServiceName, item.Codes.MoySkladCode, err)
					continue
				}
				if itemERP.IsSerialTrackable {
					log.Printf("%s (UpdateRemainsERP): товар с серийным учетом в приемку/списание не попал | erpCode = %s\n", ServiceName, item.Codes.MoySkladCode)
					continue
				}

				itemService, exists := (*itemsService)[item.Service.ServiceCode]
				if !exists {
					log.Printf("%s (UpdateRemainsERP): ошибка при получении остатков, запись не найдена или данных по остаткам нет | serviceCode = %s\n", ServiceName, item.Service.ServiceCode)
					continue
				}

				if itemERP.Stock > itemService.Stock {
					// log.Printf("на списание article = %s erpCode = %s serviceCode = %s quantityERP = %d quantityService = %d\n",
					// item.Codes.Article, item.Codes.MoySkladCode, item.Service.ServiceCode, itemERP.Stock, itemService.Stock)
					woffList = append(woffList, skladTypes.PositionsAdd{
						Quantity:   itemERP.Stock - itemService.Stock,
						Assortment: skladTypes.MetaMiddle{Meta: itemERP.ItemMeta},
					})
				} else if itemERP.Stock < itemService.Stock {
					acceptanceList = append(acceptanceList, skladTypes.PositionsAdd{
						Quantity:   itemService.Stock - itemERP.Stock,
						Assortment: skladTypes.MetaMiddle{Meta: itemERP.ItemMeta},
						Price:      itemService.Price,
					})
				}
			}
			time.Sleep(time.Millisecond * 150)
		}

		if len(acceptanceList) != 0 {
			acceptanceReq.Positions = acceptanceList
			fmt.Printf("%s: позиций в приемке %d\n", ServiceName, len(acceptanceList))
			err = erpSystem.CreateAcceptance(&acceptanceReq)
			if err != nil {
				log.Printf("%s (UpdateRemainsERP): ошибка при создании приемки | err = %s\n", ServiceName, err)
			}
		}

		woffList = removeDuplicates(woffList)

		if len(woffList) != 0 {
			woffReq.Positions = woffList
			fmt.Printf("%s: позиций в списании %d\n", ServiceName, len(woffList))
			err = erpSystem.CreateWoff(&woffReq)
			if err != nil {
				log.Printf("%s (UpdateRemainsERP): ошибка при создании списания | err = %s\n", ServiceName, err)
			}
		}

		fmt.Printf("%s: закончил обновлять остатки на мс\n", ServiceName)
		return nil
	}
}

func removeDuplicates(arr []skladTypes.PositionsAdd) []skladTypes.PositionsAdd {
	seen := make(map[string]bool)
	result := []skladTypes.PositionsAdd{}

	for _, num := range arr {
		if !seen[num.Assortment.Meta.Href] {
			seen[num.Assortment.Meta.Href] = true
			result = append(result, num)
			continue
		}
		log.Printf("удален дубликат %s\n", num.Assortment.Meta.Href)
	}

	return result
}
