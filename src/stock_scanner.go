package src

import (
	"MerlionScript/services/common"
	skladTypes "MerlionScript/services/sklad/types"
	"MerlionScript/utils/db"
	"context"
	"fmt"
	"log"
	"time"
)

// Обновляем остатки в ERP
func UpdateRemainsERP(ctx context.Context, dbInstance *db.DB, service common.Service, erpSystem common.ERPSystem) error {
	var ServiceName string = service.GetSystemName()
	var DBTableName string = service.GetDBTableName()
	//Мета организации ERP
	orgMeta, err := erpSystem.GetOrgMeta()
	if err != nil {
		log.Printf("%s (UpdateRemainsERP): ошибка при получении метаданных организации | err = %s\n", ServiceName, err)
		return err
	}
	//Мета склада ERP
	storeMeta, err := erpSystem.GetStoreMeta()
	if err != nil || storeMeta.Href == "" {
		log.Printf("%s (UpdateRemainsERP): ошибка при получении метаданных склада | err = %s\n", ServiceName, err)
		return err
	}
	//ID склада ERP
	storeUUID, err := erpSystem.GetStoreUUID()
	if err != nil || storeUUID == "" {
		log.Printf("%s (UpdateRemainsERP): ошибка при получении UUID склада | err = %s\n", ServiceName, err)
		return err
	}
	select {
	case <-ctx.Done():
		fmt.Printf("%s (UpdateRemainsERP): работу закончил из-за контекста\n", ServiceName)
		return nil
	default:
		fmt.Printf("%s: начал обновлять остатки\n", ServiceName)
		//Записи из БД
		items, err := dbInstance.GetCodesFilledMS(DBTableName)
		if err != nil || items == nil {
			log.Printf("%s (UpdateRemainsERP): ошибка при получении записей из БД | err = %s\n", ServiceName, err)
			return err
		}
		//Остатки с сервиса
		itemsService, err := service.GetStocksList()
		if err != nil || itemsService == nil {
			log.Printf("%s (UpdateRemainsERP): ошибка при получении записей из сервиса | err = %s\n", ServiceName, err)
			return err
		}
		//На увеличение остатков
		acceptanceReq := skladTypes.Acceptance{
			Organization: skladTypes.MetaMiddle{Meta: orgMeta},
			Agent:        skladTypes.MetaMiddle{Meta: orgMeta},
			Store:        skladTypes.MetaMiddle{Meta: storeMeta},
			Description:  "Automatically generated by the script",
			Applicable:   true,
		}
		//На снижение остатков
		woffReq := skladTypes.Acceptance{
			Organization: skladTypes.MetaMiddle{Meta: orgMeta},
			Agent:        skladTypes.MetaMiddle{Meta: orgMeta},
			Store:        skladTypes.MetaMiddle{Meta: storeMeta},
			Description:  "Automatically generated by the script",
			Applicable:   true,
		}
		//Список приемки
		acceptanceList := []skladTypes.PositionsAdd{}
		//Список списания
		woffList := []skladTypes.PositionsAdd{}
		for _, item := range *items {
			select {
			case <-ctx.Done():
				return nil
			default:
				//Запись ERP
				itemERP, err := erpSystem.GetItemAvails(item.Codes.MoySkladCode)
				if err != nil {
					log.Printf("%s (UpdateRemainsERP): ошибка при получении записей из ERP | err = %s\n", ServiceName, err)
					return err
				}
				if itemERP.IsSerialTrackable {
					log.Printf("%s (UpdateRemainsERP): товар с серийным учетом в приемку/списание не попал | erpCode = %s\n", ServiceName, item.Codes.MoySkladCode)
					continue
				}

				itemService, exists := (*itemsService)[item.Service.ServiceCode]
				if !exists {
					log.Printf("%s (UpdateRemainsERP): ошибка при получении остатков, запись не найдена | serviceCode = %s\n", ServiceName, item.Service)
					continue
				}

				if itemERP.Stock > itemService.Stock {
					woffList = append(woffList, skladTypes.PositionsAdd{
						Quantity:   itemERP.Stock - itemService.Stock,
						Assortment: skladTypes.MetaMiddle{Meta: itemERP.ItemMeta},
					})
				} else if itemERP.Stock < itemService.Stock {
					acceptanceList = append(acceptanceList, skladTypes.PositionsAdd{
						Quantity:   itemService.Stock - itemERP.Stock,
						Assortment: skladTypes.MetaMiddle{Meta: itemERP.ItemMeta},
						Price:      itemService.Price * 100,
					})
				}
			}
			time.Sleep(time.Millisecond * 150)
		}

		if len(acceptanceList) != 0 {
			acceptanceReq.Positions = acceptanceList
			fmt.Printf("%s: позиций в приемке %d\n", ServiceName, len(acceptanceList))
			err = erpSystem.CreateAcceptance(&acceptanceReq)
			if err != nil {
				log.Printf("%s (UpdateRemainsERP): ошибка при создании приемки | err = %s\n", ServiceName, err)
			}
		}

		if len(woffList) != 0 {
			woffReq.Positions = woffList
			fmt.Printf("%s: позиций в списании %d\n", ServiceName, len(woffList))
			err = erpSystem.CreateWoff(&woffReq)
			if err != nil {
				log.Printf("%s (UpdateRemainsERP): ошибка при создании списания | err = %s\n", ServiceName, err)
			}
		}

		fmt.Printf("%s: закончил обновлять остатки на мс\n", ServiceName)
		return nil
	}
}
